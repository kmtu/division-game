<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Èô§Ê≥ïÁ∑¥Áøí</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 40px;
      max-width: 500px;
      width: 100%;
    }

    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 20px;
      font-size: 2rem;
    }

    /* Player section */
    .player-section {
      text-align: center;
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid #e5e7eb;
    }

    .current-player {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: #f3f4f6;
      padding: 10px 20px;
      border-radius: 30px;
    }

    .player-icon {
      font-size: 1.5rem;
    }

    .player-name {
      font-size: 1.2rem;
      font-weight: bold;
      color: #374151;
    }

    .switch-player-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 6px 14px;
      border-radius: 15px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: background 0.2s;
    }

    .switch-player-btn:hover {
      background: #5a6fd6;
    }

    /* Main menu */
    #menu-screen {
      display: block;
    }

    #game-screen {
      display: none;
    }

    .level-btn {
      display: block;
      width: 100%;
      padding: 15px 20px;
      margin-bottom: 12px;
      border: none;
      border-radius: 12px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-size: 1.1rem;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      text-align: left;
    }

    .level-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    .level-btn:active {
      transform: translateY(0);
    }

    .level-btn .level-name {
      font-weight: bold;
      display: block;
    }

    .level-btn .level-best {
      font-size: 0.85rem;
      opacity: 0.9;
      margin-top: 4px;
    }

    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal {
      background: white;
      border-radius: 20px;
      padding: 30px;
      max-width: 400px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal h2 {
      margin-bottom: 20px;
      color: #333;
      text-align: center;
    }

    .player-list {
      margin-bottom: 20px;
    }

    .player-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 15px;
      border-radius: 10px;
      margin-bottom: 8px;
      background: #f3f4f6;
      cursor: pointer;
      transition: background 0.2s;
    }

    .player-item:hover {
      background: #e5e7eb;
    }

    .player-item.active {
      background: #667eea;
      color: white;
    }

    .player-item-name {
      font-weight: 500;
    }

    .player-item-edit-btn {
      background: none;
      border: none;
      color: #9ca3af;
      cursor: pointer;
      font-size: 1.2rem;
      padding: 5px 10px;
      opacity: 0.7;
      transition: opacity 0.2s, color 0.2s;
    }

    .player-item-edit-btn:hover {
      opacity: 1;
      color: #667eea;
    }

    .player-item.active .player-item-edit-btn {
      color: rgba(255, 255, 255, 0.7);
    }

    .player-item.active .player-item-edit-btn:hover {
      color: white;
    }

    .add-player-btn-large {
      display: block;
      width: 100%;
      padding: 15px;
      margin-bottom: 15px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.1rem;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .add-player-btn-large:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    /* Edit view styles */
    .edit-view-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    .edit-view-header h2 {
      margin: 0;
      flex: 1;
      text-align: center;
      padding-right: 34px; /* Balance the back button */
    }

    .back-to-list-btn {
      background: #e5e7eb;
      border: none;
      width: 34px;
      height: 34px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.2rem;
      color: #374151;
      transition: background 0.2s;
    }

    .back-to-list-btn:hover {
      background: #d1d5db;
    }

    .edit-player-form {
      margin-bottom: 20px;
    }

    .edit-label {
      display: block;
      font-size: 0.9rem;
      color: #6b7280;
      margin-bottom: 8px;
    }

    .edit-player-input {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e5e7eb;
      border-radius: 10px;
      font-size: 1.1rem;
      outline: none;
      box-sizing: border-box;
    }

    .edit-player-input:focus {
      border-color: #667eea;
    }

    .save-player-btn {
      display: block;
      width: 100%;
      padding: 15px;
      margin-bottom: 10px;
      background: #22c55e;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.1rem;
      transition: background 0.2s;
    }

    .save-player-btn:hover {
      background: #16a34a;
    }

    .delete-player-btn {
      display: block;
      width: 100%;
      padding: 12px;
      background: white;
      color: #ef4444;
      border: 2px solid #ef4444;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
    }

    .delete-player-btn:hover {
      background: #ef4444;
      color: white;
    }

    .modal-close-btn {
      display: block;
      width: 100%;
      padding: 12px;
      background: #e5e7eb;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1rem;
      color: #374151;
      transition: background 0.2s;
    }

    .modal-close-btn:hover {
      background: #d1d5db;
    }

    /* Avatar picker */
    .avatar-section-label {
      font-size: 0.9rem;
      color: #6b7280;
      margin-bottom: 8px;
    }

    .avatar-picker {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;
      margin-bottom: 15px;
    }

    .avatar-option {
      font-size: 1.8rem;
      padding: 8px;
      border: 2px solid #e5e7eb;
      border-radius: 10px;
      cursor: pointer;
      text-align: center;
      background: white;
      transition: all 0.2s;
    }

    .avatar-option:hover {
      border-color: #a5b4fc;
      background: #f5f7ff;
    }

    .avatar-option.selected {
      border-color: #667eea;
      background: #eef2ff;
    }

    .custom-avatar-input {
      grid-column: span 5;
      display: flex;
      gap: 8px;
      margin-top: 5px;
    }

    .custom-avatar-input input {
      flex: 1;
      padding: 8px 12px;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      font-size: 1.2rem;
      text-align: center;
      outline: none;
    }

    .custom-avatar-input input:focus {
      border-color: #667eea;
    }

    .custom-avatar-input button {
      padding: 8px 16px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
    }

    .custom-avatar-input button:hover {
      background: #5a6fd6;
    }

    /* Game screen */
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }

    .back-btn {
      background: #e5e7eb;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      color: #374151;
      transition: background 0.2s;
    }

    .back-btn:hover {
      background: #d1d5db;
    }

    .game-info {
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .question-counter {
      font-size: 1rem;
      color: #374151;
    }

    .timer {
      font-size: 0.9rem;
      color: #9ca3af;
      font-family: monospace;
    }

    .timer.paused {
      color: #22c55e;
    }

    .timer.paused::before {
      content: '‚è∏ ';
    }

    /* Long division - using CSS Grid for alignment */
    .division-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 30px 0;
      font-family: "Courier New", monospace;
      font-size: 2rem;
    }

    .division-grid {
      display: grid;
      grid-template-columns: auto auto;
      gap: 0;
    }

    /* Row 1: spacer + quotient */
    .divisor-spacer {
      /* Placeholder, same width as divisor */
    }

    .quotient-cell {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      padding: 0 15px 5px 10px;
    }

    .quotient-display {
      font-weight: bold;
      color: #333;
    }

    .quotient-placeholder {
      font-weight: bold;
      color: #9ca3af;
    }

    /* Number pad for mobile */
    .number-pad {
      display: none;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      max-width: 240px;
      margin: 20px auto;
    }

    /* Show on touch devices */
    @media (pointer: coarse) {
      .number-pad {
        display: grid;
      }
    }

    .num-btn {
      padding: 15px;
      font-size: 1.5rem;
      font-weight: bold;
      border-radius: 12px;
      border: 2px solid #667eea;
      background: white;
      color: #667eea;
      cursor: pointer;
      transition: all 0.2s;
    }

    .num-btn:hover {
      background: #667eea;
      color: white;
    }

    .num-btn:active {
      transform: scale(0.95);
    }

    /* Row 2: divisor + dividend */
    .divisor-cell {
      display: flex;
      align-items: flex-start;
      justify-content: flex-end;
      padding-right: 8px;
      padding-top: 8px;
    }

    .dividend-cell {
      border-left: 3px solid #333;
      border-top: 3px solid #333;
      border-top-left-radius: 10px;
      padding: 8px 15px 8px 10px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
    }

    /* Calculation steps - also aligned */
    .calc-spacer {
      /* Same width as divisor */
    }

    .calc-cell {
      padding: 0 15px 0 10px;
    }

    .calc-row {
      display: flex;
      justify-content: flex-end;
    }

    .calc-subtract {
      color: #ef4444;
    }

    .calc-line {
      border-top: 2px solid #333;
      margin: 5px 0;
    }

    .calc-remainder {
      font-weight: bold;
    }

    .calc-remainder.correct {
      color: #22c55e;
    }

    .calc-remainder.incorrect {
      color: #ef4444;
    }

    .calculation {
      display: none;
    }

    .calculation.show {
      display: contents;
    }

    /* Result display */
    .result-icon {
      text-align: center;
      font-size: 5rem;
      margin: 20px 0;
      display: none;
    }

    .result-icon.show {
      display: block;
      animation: pop 0.3s ease-out;
    }

    @keyframes pop {
      0% { transform: scale(0); }
      70% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    .result-icon.correct {
      color: #22c55e;
    }

    .result-icon.incorrect {
      color: #ef4444;
    }

    .continue-hint {
      text-align: center;
      color: #9ca3af;
      font-size: 0.95rem;
      margin-top: 20px;
      display: none;
    }

    .continue-hint.show {
      display: block;
    }

    /* Show desktop hint on non-touch devices, mobile hint on touch devices */
    @media (pointer: coarse) {
      .continue-hint-desktop.show {
        display: none;
      }
      .continue-hint-mobile.show {
        display: block;
      }
    }

    @media (pointer: fine) {
      .continue-hint-desktop.show {
        display: block;
      }
      .continue-hint-mobile.show {
        display: none;
      }
    }

    .penalty-hint {
      text-align: center;
      color: #ef4444;
      font-size: 1.5rem;
      font-weight: bold;
      margin-top: 10px;
      display: none;
    }

    .penalty-hint.show {
      display: block;
      animation: shake 0.3s ease-out;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    /* Language toggle */
    .lang-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      border: 2px solid #667eea;
      color: #667eea;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
      font-size: 0.9rem;
      z-index: 1000;
      transition: all 0.2s;
    }

    .lang-toggle:hover {
      background: #667eea;
      color: white;
    }

    /* End screen */
    .end-screen {
      text-align: center;
      display: none;
    }

    .end-screen.show {
      display: block;
    }

    .end-time {
      font-size: 3rem;
      color: #667eea;
      font-weight: bold;
      margin: 20px 0;
    }

    .new-record {
      color: #22c55e;
      font-size: 1.2rem;
      margin-bottom: 20px;
    }

    .end-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 15px 40px;
      border-radius: 10px;
      font-size: 1.1rem;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .end-btn:hover {
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <!-- Language toggle -->
  <button class="lang-toggle" id="lang-toggle" onclick="toggleLanguage()">EN</button>

  <div class="container">
    <!-- Main menu -->
    <div id="menu-screen">
      <h1>Èô§Ê≥ïÁ∑¥Áøí</h1>
      <div class="player-section">
        <div class="current-player">
          <span class="player-icon">üë§</span>
          <span class="player-name" id="current-player-name">Áé©ÂÆ∂</span>
          <button class="switch-player-btn" onclick="openPlayerModal()">ÂàáÊèõ</button>
        </div>
      </div>
      <div id="level-buttons"></div>
    </div>

    <!-- Game screen -->
    <div id="game-screen">
      <div class="game-header">
        <button class="back-btn" onclick="goToMenu()">ËøîÂõû</button>
        <div class="game-info">
          <span class="question-counter" id="question-counter">Á¨¨ 1/10 È°å</span>
          <span class="timer" id="timer">0:00</span>
        </div>
      </div>

      <div id="game-content">
        <div class="division-container">
          <div class="division-grid" id="division-grid">
            <!-- Row 1: Quotient -->
            <div class="divisor-spacer" id="divisor-spacer"></div>
            <div class="quotient-cell" id="quotient-cell">
              <span class="quotient-placeholder">_</span>
            </div>
            <!-- Row 2: Divisor | Dividend -->
            <div class="divisor-cell" id="divisor-cell"></div>
            <div class="dividend-cell" id="dividend-cell"></div>
            <!-- Row 3-4: Calculation (hidden until answer submitted) -->
            <div class="calculation" id="calculation">
              <div class="calc-spacer"></div>
              <div class="calc-cell">
                <div class="calc-row calc-subtract" id="calc-product"></div>
                <div class="calc-line"></div>
                <div class="calc-row calc-remainder" id="calc-remainder"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="result-icon" id="result-icon"></div>
        <div class="penalty-hint" id="penalty-hint">+10Áßí</div>
        <div class="continue-hint continue-hint-desktop" id="continue-hint">Êåâ Enter ÁπºÁ∫å</div>
        <div class="continue-hint continue-hint-mobile" id="continue-hint-mobile">ÈªûÊìä‰ªªÊÑèËôïÁπºÁ∫å</div>

        <!-- Number pad for mobile -->
        <div class="number-pad" id="number-pad">
          <button class="num-btn" data-num="1">1</button>
          <button class="num-btn" data-num="2">2</button>
          <button class="num-btn" data-num="3">3</button>
          <button class="num-btn" data-num="4">4</button>
          <button class="num-btn" data-num="5">5</button>
          <button class="num-btn" data-num="6">6</button>
          <button class="num-btn" data-num="7">7</button>
          <button class="num-btn" data-num="8">8</button>
          <button class="num-btn" data-num="9">9</button>
        </div>
      </div>

      <div class="end-screen" id="end-screen">
        <h2>ÈóúÂç°ÂÆåÊàêÔºÅ</h2>
        <div class="end-time" id="end-time">0:00</div>
        <div class="new-record" id="new-record" style="display: none;">Êñ∞Á¥ÄÈåÑÔºÅ</div>
        <button class="end-btn" onclick="goToMenu()">ÂõûÂà∞‰∏ªÁï´Èù¢</button>
      </div>
    </div>
  </div>

  <!-- Player management modal -->
  <div class="modal-overlay" id="player-modal">
    <div class="modal">
      <!-- View 1: Player List -->
      <div id="player-list-view">
        <h2 id="modal-title-list">Áé©ÂÆ∂ÁÆ°ÁêÜ</h2>
        <div class="player-list" id="player-list"></div>
        <button class="add-player-btn-large" id="add-player-btn-large" onclick="showEditView(null)">+ Êñ∞Â¢ûÁé©ÂÆ∂</button>
        <button class="modal-close-btn" onclick="closePlayerModal()">ÈóúÈñâ</button>
      </div>

      <!-- View 2: Edit/Add Player -->
      <div id="player-edit-view" style="display: none;">
        <div class="edit-view-header">
          <button class="back-to-list-btn" onclick="showListView()">‚Üê</button>
          <h2 id="modal-title-edit">Á∑®ËºØÁé©ÂÆ∂</h2>
        </div>
        <div class="avatar-section-label" id="avatar-section-label">ÈÅ∏ÊìáÈ†≠ÂÉè</div>
        <div class="avatar-picker" id="avatar-picker"></div>
        <div class="edit-player-form">
          <label class="edit-label" id="edit-name-label">Áé©ÂÆ∂ÂêçÁ®±</label>
          <input type="text" class="edit-player-input" id="edit-player-input" placeholder="Ëº∏ÂÖ•Áé©ÂÆ∂ÂêçÁ®±" maxlength="10">
        </div>
        <button class="save-player-btn" id="save-player-btn" onclick="savePlayer()">ÂÑ≤Â≠ò</button>
        <button class="delete-player-btn" id="delete-player-btn" onclick="deleteCurrentEditPlayer()">Âà™Èô§Áé©ÂÆ∂</button>
      </div>
    </div>
  </div>

  <script>
    // Level configuration
    const LEVELS = [
      { dividendDigits: 1, divisorDigits: 1 },
      { dividendDigits: 2, divisorDigits: 1 },
      { dividendDigits: 2, divisorDigits: 2 },
      { dividendDigits: 3, divisorDigits: 2 },
      { dividendDigits: 3, divisorDigits: 3 },
      { dividendDigits: 4, divisorDigits: 3 },
    ];

    const TOTAL_QUESTIONS = 10;

    // Avatar options for player profiles
    const AVATARS = [
      'ü¶Å', 'üêº', 'ü¶ä', 'üê∏', 'ü¶Ñ',  // Animals
      'üê∂', 'üê±', 'üê∞', 'üêª', 'üê®',  // Cute animals
      'ü¶ã', 'üê¢', 'ü¶ñ', 'üêô', 'ü¶à',  // More animals
      'üöÄ', '‚≠ê', 'üåà', 'üéÆ', 'üé®',  // Fun objects
    ];

    // ==================== Internationalization ====================

    const i18n = {
      zh: {
        title: 'Èô§Ê≥ïÁ∑¥Áøí',
        switchPlayer: 'ÂàáÊèõ',
        back: 'ËøîÂõû',
        penaltyHint: '+10Áßí',
        continueHint: 'Êåâ Enter ÁπºÁ∫å',
        continueHintMobile: 'ÈªûÊìä‰ªªÊÑèËôïÁπºÁ∫å',
        levelComplete: 'ÈóúÂç°ÂÆåÊàêÔºÅ',
        newRecord: 'Êñ∞Á¥ÄÈåÑÔºÅ',
        returnToMenu: 'ÂõûÂà∞‰∏ªÁï´Èù¢',
        playerManagement: 'ÈÅ∏ÊìáÁé©ÂÆ∂',
        add: 'Êñ∞Â¢û',
        close: 'ÈóúÈñâ',
        inputPlaceholder: 'Ëº∏ÂÖ•Êñ∞Áé©ÂÆ∂ÂêçÁ®±',
        levelFormat: (index, name) => `Á¨¨ ${index + 1} ÈóúÔºö${name}`,
        levelName: (dividend, divisor) => `${dividend}‰ΩçÊï∏ √∑ ${divisor}‰ΩçÊï∏`,
        questionCounter: (current, total) => `Á¨¨ ${current}/${total} È°å`,
        bestTime: (time) => `ÊúÄ‰Ω≥Ôºö${time}`,
        notAttempted: 'Â∞öÊú™ÊåëÊà∞',
        defaultPlayer: 'Áé©ÂÆ∂1',
        playerExists: 'Ê≠§Áé©ÂÆ∂ÂêçÁ®±Â∑≤Â≠òÂú®ÔºÅ',
        keepOnePlayer: 'Ëá≥Â∞ëË¶Å‰øùÁïô‰∏ÄÂÄãÁé©ÂÆ∂ÔºÅ',
        deleteConfirm: (name) => `Á¢∫ÂÆöË¶ÅÂà™Èô§Áé©ÂÆ∂„Äå${name}„ÄçÂóéÔºüÊâÄÊúâÁ¥ÄÈåÑÂ∞áÊúÉÊ∂àÂ§±ÔºÅ`,
        selectAvatar: 'ÈÅ∏ÊìáÈ†≠ÂÉè',
        customAvatar: 'ÊàñËº∏ÂÖ•Ëá™Ë®Ç',
        apply: 'Â•óÁî®',
        addNewPlayer: '+ Êñ∞Â¢ûÁé©ÂÆ∂',
        editPlayer: 'Á∑®ËºØÁé©ÂÆ∂',
        addPlayer: 'Êñ∞Â¢ûÁé©ÂÆ∂',
        playerName: 'Áé©ÂÆ∂ÂêçÁ®±',
        namePlaceholder: 'Ëº∏ÂÖ•Áé©ÂÆ∂ÂêçÁ®±',
        save: 'ÂÑ≤Â≠ò',
        deletePlayer: 'Âà™Èô§Áé©ÂÆ∂',
        nameRequired: 'Ë´ãËº∏ÂÖ•Áé©ÂÆ∂ÂêçÁ®±ÔºÅ',
      },
      en: {
        title: 'Division Practice',
        switchPlayer: 'Switch',
        back: 'Back',
        penaltyHint: '+10s',
        continueHint: 'Press Enter to continue',
        continueHintMobile: 'Tap anywhere to continue',
        levelComplete: 'Level Complete!',
        newRecord: 'New Record!',
        returnToMenu: 'Return to Menu',
        playerManagement: 'Select Player',
        add: 'Add',
        close: 'Close',
        inputPlaceholder: 'Enter player name',
        levelFormat: (index, name) => `Level ${index + 1}: ${name}`,
        levelName: (dividend, divisor) => `${dividend}-digit √∑ ${divisor}-digit`,
        questionCounter: (current, total) => `Question ${current}/${total}`,
        bestTime: (time) => `Best: ${time}`,
        notAttempted: 'Not attempted',
        defaultPlayer: 'Player 1',
        playerExists: 'Player name already exists!',
        keepOnePlayer: 'Must keep at least one player!',
        deleteConfirm: (name) => `Delete player "${name}"? All records will be lost!`,
        selectAvatar: 'Select Avatar',
        customAvatar: 'or enter custom',
        apply: 'Apply',
        addNewPlayer: '+ Add Player',
        editPlayer: 'Edit Player',
        addPlayer: 'Add Player',
        playerName: 'Player Name',
        namePlaceholder: 'Enter player name',
        save: 'Save',
        deletePlayer: 'Delete Player',
        nameRequired: 'Please enter a player name!',
      }
    };

    let currentLang = localStorage.getItem('divisionGameLang') || 'zh';

    function t(key) {
      return i18n[currentLang][key];
    }

    function toggleLanguage() {
      currentLang = currentLang === 'zh' ? 'en' : 'zh';
      localStorage.setItem('divisionGameLang', currentLang);
      updateLanguage();
    }

    function updateLanguage() {
      // Update toggle button text
      document.getElementById('lang-toggle').textContent = currentLang === 'zh' ? 'EN' : '‰∏≠';

      // Update static text elements
      document.querySelector('#menu-screen h1').textContent = t('title');
      document.querySelector('.switch-player-btn').textContent = t('switchPlayer');
      document.querySelector('.back-btn').textContent = t('back');
      document.getElementById('penalty-hint').textContent = t('penaltyHint');
      document.getElementById('continue-hint').textContent = t('continueHint');
      document.getElementById('continue-hint-mobile').textContent = t('continueHintMobile');
      document.querySelector('#end-screen h2').textContent = t('levelComplete');
      document.getElementById('new-record').textContent = t('newRecord');
      document.querySelector('.end-btn').textContent = t('returnToMenu');

      // Player modal elements
      document.getElementById('modal-title-list').textContent = t('playerManagement');
      document.getElementById('add-player-btn-large').textContent = t('addNewPlayer');
      document.querySelector('.modal-close-btn').textContent = t('close');
      document.getElementById('avatar-section-label').textContent = t('selectAvatar');
      document.getElementById('edit-name-label').textContent = t('playerName');
      document.getElementById('edit-player-input').placeholder = t('namePlaceholder');
      document.getElementById('save-player-btn').textContent = t('save');
      document.getElementById('delete-player-btn').textContent = t('deletePlayer');

      // Update page title
      document.title = t('title');

      // Re-render level buttons with new language
      renderLevelButtons();
    }

    // Game state
    let gameState = {
      currentLevel: null,
      currentQuestion: 0,
      startTime: null,
      dividend: null,
      divisor: null,
      correctAnswer: null,
      waitingForEnter: false,
      lastAnswerCorrect: false,
      timerInterval: null,
      lastDividend: null,
      lastDivisor: null,
      userInput: null,
    };

    // DOM elements
    const menuScreen = document.getElementById('menu-screen');
    const gameScreen = document.getElementById('game-screen');
    const levelButtons = document.getElementById('level-buttons');
    const questionCounter = document.getElementById('question-counter');
    const timerDisplay = document.getElementById('timer');
    const divisorSpacer = document.getElementById('divisor-spacer');
    const divisorCell = document.getElementById('divisor-cell');
    const dividendCell = document.getElementById('dividend-cell');
    const quotientCell = document.getElementById('quotient-cell');
    const calculation = document.getElementById('calculation');
    const calcProduct = document.getElementById('calc-product');
    const calcRemainder = document.getElementById('calc-remainder');
    const resultIcon = document.getElementById('result-icon');
    const penaltyHint = document.getElementById('penalty-hint');
    const continueHint = document.getElementById('continue-hint');
    const continueHintMobile = document.getElementById('continue-hint-mobile');
    const gameContent = document.getElementById('game-content');
    const endScreen = document.getElementById('end-screen');
    const endTime = document.getElementById('end-time');
    const newRecord = document.getElementById('new-record');
    const currentPlayerNameDisplay = document.getElementById('current-player-name');
    const playerModal = document.getElementById('player-modal');
    const playerList = document.getElementById('player-list');
    const avatarPicker = document.getElementById('avatar-picker');
    const playerListView = document.getElementById('player-list-view');
    const playerEditView = document.getElementById('player-edit-view');
    const editPlayerInput = document.getElementById('edit-player-input');
    const deletePlayerBtn = document.getElementById('delete-player-btn');
    const modalTitleEdit = document.getElementById('modal-title-edit');

    // Player being edited (null = adding new player, string = editing existing player)
    let editingPlayer = null;

    // ==================== Sound Effects ====================

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    function playCorrectSound() {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
      oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
      oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5

      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.4);
    }

    function playWrongSound() {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.type = 'sawtooth';
      oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.3);

      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    }

    // ==================== Profile Management ====================

    function loadProfiles() {
      const saved = localStorage.getItem('divisionGameProfiles');
      if (saved) {
        return JSON.parse(saved);
      }
      // Create default player
      const defaultPlayerName = t('defaultPlayer');
      const defaultProfiles = {
        currentPlayer: defaultPlayerName,
        players: {
          [defaultPlayerName]: { bestTimes: LEVELS.map(() => null), avatar: AVATARS[0] }
        }
      };
      saveProfiles(defaultProfiles);
      return defaultProfiles;
    }

    function saveProfiles(profiles) {
      localStorage.setItem('divisionGameProfiles', JSON.stringify(profiles));
    }

    function getCurrentPlayerName() {
      const profiles = loadProfiles();
      return profiles.currentPlayer;
    }

    function loadBestTimes() {
      const profiles = loadProfiles();
      const playerData = profiles.players[profiles.currentPlayer];
      if (playerData && playerData.bestTimes) {
        return playerData.bestTimes;
      }
      return LEVELS.map(() => null);
    }

    function saveBestTime(levelIndex, time) {
      const profiles = loadProfiles();
      const currentPlayer = profiles.currentPlayer;
      if (!profiles.players[currentPlayer]) {
        profiles.players[currentPlayer] = { bestTimes: LEVELS.map(() => null) };
      }
      const currentBest = profiles.players[currentPlayer].bestTimes[levelIndex];
      if (currentBest === null || time < currentBest) {
        profiles.players[currentPlayer].bestTimes[levelIndex] = time;
        saveProfiles(profiles);
        return true; // New record
      }
      return false;
    }

    function switchPlayer(name) {
      const profiles = loadProfiles();
      if (profiles.players[name]) {
        profiles.currentPlayer = name;
        saveProfiles(profiles);
        updatePlayerDisplay();
        renderLevelButtons();
        renderPlayerList();
      }
    }

    function deletePlayer(name) {
      const profiles = loadProfiles();
      const playerNames = Object.keys(profiles.players);

      if (playerNames.length <= 1) {
        alert(t('keepOnePlayer'));
        return;
      }

      if (!confirm(t('deleteConfirm')(name))) {
        return;
      }

      delete profiles.players[name];

      // If deleted player was current, switch to another
      if (profiles.currentPlayer === name) {
        profiles.currentPlayer = Object.keys(profiles.players)[0];
      }

      saveProfiles(profiles);
      updatePlayerDisplay();
      renderLevelButtons();
      renderPlayerList();
    }

    function getCurrentPlayerAvatar() {
      const profiles = loadProfiles();
      const playerData = profiles.players[profiles.currentPlayer];
      return playerData?.avatar || 'üë§';
    }

    function changePlayerAvatar(name, avatar) {
      const profiles = loadProfiles();
      if (profiles.players[name]) {
        profiles.players[name].avatar = avatar;
        saveProfiles(profiles);
        updatePlayerDisplay();
        renderPlayerList();
      }
    }

    function updatePlayerDisplay() {
      const avatar = getCurrentPlayerAvatar();
      document.querySelector('.player-icon').textContent = avatar;
      currentPlayerNameDisplay.textContent = getCurrentPlayerName();
    }

    function renderAvatarPicker() {
      const profiles = loadProfiles();
      const currentPlayer = profiles.currentPlayer;
      const currentAvatar = profiles.players[currentPlayer]?.avatar || 'üë§';

      avatarPicker.innerHTML = '';
      AVATARS.forEach(avatar => {
        const btn = document.createElement('div');
        btn.className = 'avatar-option' + (avatar === currentAvatar ? ' selected' : '');
        btn.textContent = avatar;
        btn.onclick = () => {
          // Immediately change current player's avatar
          changePlayerAvatar(currentPlayer, avatar);
          renderAvatarPicker();
        };
        avatarPicker.appendChild(btn);
      });

      // Custom emoji input
      const customContainer = document.createElement('div');
      customContainer.className = 'custom-avatar-input';

      const customInput = document.createElement('input');
      customInput.type = 'text';
      customInput.maxLength = 2;
      customInput.placeholder = t('customAvatar');

      const applyBtn = document.createElement('button');
      applyBtn.textContent = t('apply');
      applyBtn.onclick = () => {
        const emoji = customInput.value.trim();
        if (emoji) {
          changePlayerAvatar(currentPlayer, emoji);
          renderAvatarPicker();
        }
      };

      customInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          applyBtn.click();
        }
      });

      customContainer.appendChild(customInput);
      customContainer.appendChild(applyBtn);
      avatarPicker.appendChild(customContainer);
    }

    function openPlayerModal() {
      showListView();
      playerModal.classList.add('show');
    }

    function closePlayerModal() {
      playerModal.classList.remove('show');
    }

    function showListView() {
      playerListView.style.display = 'block';
      playerEditView.style.display = 'none';
      editingPlayer = null;
      renderPlayerList();
    }

    function showEditView(playerName) {
      playerListView.style.display = 'none';
      playerEditView.style.display = 'block';
      editingPlayer = playerName;

      if (playerName === null) {
        // Adding new player
        modalTitleEdit.textContent = t('addPlayer');
        editPlayerInput.value = '';
        deletePlayerBtn.style.display = 'none';
        // Reset avatar picker to first avatar for new player
        renderAvatarPickerForNew();
      } else {
        // Editing existing player
        modalTitleEdit.textContent = t('editPlayer');
        editPlayerInput.value = playerName;
        deletePlayerBtn.style.display = 'block';
        renderAvatarPicker();
      }
      editPlayerInput.focus();
    }

    function renderPlayerList() {
      const profiles = loadProfiles();
      const currentPlayer = profiles.currentPlayer;
      const playerNames = Object.keys(profiles.players);

      playerList.innerHTML = '';
      playerNames.forEach(name => {
        const playerData = profiles.players[name];
        const avatar = playerData.avatar || 'üë§';

        const item = document.createElement('div');
        item.className = 'player-item' + (name === currentPlayer ? ' active' : '');
        item.onclick = () => {
          // Switch to this player and close modal
          if (name !== currentPlayer) {
            switchPlayer(name);
          }
          closePlayerModal();
        };

        const avatarSpan = document.createElement('span');
        avatarSpan.style.marginRight = '8px';
        avatarSpan.style.fontSize = '1.3rem';
        avatarSpan.textContent = avatar;

        const nameSpan = document.createElement('span');
        nameSpan.className = 'player-item-name';
        nameSpan.textContent = name;

        const leftContainer = document.createElement('div');
        leftContainer.style.display = 'flex';
        leftContainer.style.alignItems = 'center';
        leftContainer.appendChild(avatarSpan);
        leftContainer.appendChild(nameSpan);

        const editBtn = document.createElement('button');
        editBtn.className = 'player-item-edit-btn';
        editBtn.textContent = '‚úé';
        editBtn.onclick = (e) => {
          e.stopPropagation();
          // Switch to this player first, then edit
          if (name !== currentPlayer) {
            switchPlayer(name);
          }
          showEditView(name);
        };

        item.appendChild(leftContainer);
        item.appendChild(editBtn);
        playerList.appendChild(item);
      });
    }

    function savePlayer() {
      const newName = editPlayerInput.value.trim();
      if (!newName) {
        alert(t('nameRequired'));
        return;
      }

      const profiles = loadProfiles();

      if (editingPlayer === null) {
        // Adding new player
        if (profiles.players[newName]) {
          alert(t('playerExists'));
          return;
        }
        // Get the currently selected avatar from the temp state
        profiles.players[newName] = { bestTimes: LEVELS.map(() => null), avatar: tempNewAvatar || AVATARS[0] };
        profiles.currentPlayer = newName;
        saveProfiles(profiles);
        tempNewAvatar = null;
      } else {
        // Editing existing player
        if (newName !== editingPlayer) {
          // Name changed
          if (profiles.players[newName]) {
            alert(t('playerExists'));
            return;
          }
          // Copy data to new name
          profiles.players[newName] = profiles.players[editingPlayer];
          delete profiles.players[editingPlayer];

          // Update current player if renamed
          if (profiles.currentPlayer === editingPlayer) {
            profiles.currentPlayer = newName;
          }
          saveProfiles(profiles);
        }
      }

      updatePlayerDisplay();
      renderLevelButtons();
      showListView();
    }

    function deleteCurrentEditPlayer() {
      if (editingPlayer === null) return;
      deletePlayer(editingPlayer);
      showListView();
    }

    // Temporary avatar for new player creation
    let tempNewAvatar = null;

    function renderAvatarPickerForNew() {
      tempNewAvatar = tempNewAvatar || AVATARS[0];

      avatarPicker.innerHTML = '';
      AVATARS.forEach(avatar => {
        const btn = document.createElement('div');
        btn.className = 'avatar-option' + (avatar === tempNewAvatar ? ' selected' : '');
        btn.textContent = avatar;
        btn.onclick = () => {
          tempNewAvatar = avatar;
          renderAvatarPickerForNew();
        };
        avatarPicker.appendChild(btn);
      });

      // Custom emoji input
      const customContainer = document.createElement('div');
      customContainer.className = 'custom-avatar-input';

      const customInput = document.createElement('input');
      customInput.type = 'text';
      customInput.maxLength = 2;
      customInput.placeholder = t('customAvatar');

      const applyBtn = document.createElement('button');
      applyBtn.textContent = t('apply');
      applyBtn.onclick = () => {
        const emoji = customInput.value.trim();
        if (emoji) {
          tempNewAvatar = emoji;
          renderAvatarPickerForNew();
        }
      };

      customInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          applyBtn.click();
        }
      });

      customContainer.appendChild(customInput);
      customContainer.appendChild(applyBtn);
      avatarPicker.appendChild(customContainer);
    }

    // ==================== Game Logic ====================

    // Initialize
    function init() {
      updateLanguage();
      updatePlayerDisplay();
      renderLevelButtons();
      setupEventListeners();
    }

    // Render level buttons
    function renderLevelButtons() {
      const bestTimes = loadBestTimes();
      levelButtons.innerHTML = '';

      LEVELS.forEach((level, index) => {
        const btn = document.createElement('button');
        btn.className = 'level-btn';
        const bestTime = bestTimes[index];
        const levelName = t('levelName')(level.dividendDigits, level.divisorDigits);
        const levelText = t('levelFormat')(index, levelName);
        const bestText = bestTime !== null ? t('bestTime')(formatTime(bestTime)) : t('notAttempted');

        btn.innerHTML = `
          <span class="level-name">${levelText}</span>
          <span class="level-best">${bestText}</span>
        `;
        btn.onclick = () => startLevel(index);
        levelButtons.appendChild(btn);
      });
    }

    // Set up event listeners
    function setupEventListeners() {
      document.addEventListener('keydown', handleGlobalKeydown);

      // Edit player input Enter key event
      editPlayerInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          savePlayer();
        }
      });

      // Close modal when clicking outside
      playerModal.addEventListener('click', (e) => {
        if (e.target === playerModal) {
          closePlayerModal();
        }
      });

      // Number pad button handlers (for mobile)
      document.querySelectorAll('.num-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();

          // If in feedback state after wrong answer, reset and submit new answer
          if (gameState.waitingForEnter && !gameState.lastAnswerCorrect) {
            resetQuestion();
            const num = Number.parseInt(btn.dataset.num);
            gameState.userInput = num;
            displayUserInput();
            submitAnswer();
            return;
          }

          // If in feedback state after correct answer, go to next question
          if (gameState.waitingForEnter && gameState.lastAnswerCorrect) {
            nextQuestion();
            return;
          }

          // Normal submission
          const num = Number.parseInt(btn.dataset.num);
          gameState.userInput = num;
          displayUserInput();
          submitAnswer();
        });
      });

      // Tap anywhere to continue (for mobile, during feedback state)
      gameContent.addEventListener('click', (e) => {
        if (!gameState.waitingForEnter) return;
        if (e.target.closest('.num-btn')) return;

        e.preventDefault();
        if (gameState.lastAnswerCorrect) {
          nextQuestion();
        } else {
          resetQuestion();
        }
      });
    }

    // Handle global keydown
    function handleGlobalKeydown(e) {
      // Esc always goes back to menu (when in game)
      if (e.key === 'Escape' && gameScreen.style.display === 'block') {
        e.preventDefault();
        goToMenu();
        return;
      }

      // If on end screen, press Enter to return to menu
      if (e.key === 'Enter' && endScreen.classList.contains('show')) {
        e.preventDefault();
        goToMenu();
        return;
      }

      // If waiting for Enter to continue
      if (e.key === 'Enter' && gameState.waitingForEnter) {
        e.preventDefault();
        if (gameState.lastAnswerCorrect) {
          nextQuestion();
        } else {
          resetQuestion();
        }
        return;
      }

      // During active gameplay (not waiting, not ended, game screen visible)
      if (gameScreen.style.display === 'block' &&
          !gameState.waitingForEnter &&
          !endScreen.classList.contains('show')) {

        // Number keys: set input
        if (e.key >= '0' && e.key <= '9') {
          e.preventDefault();
          gameState.userInput = Number.parseInt(e.key);
          displayUserInput();
        }

        // Backspace: clear input
        if (e.key === 'Backspace') {
          e.preventDefault();
          gameState.userInput = null;
          displayEmptyInput();
        }

        // Enter: submit if we have input
        if (e.key === 'Enter' && gameState.userInput !== null) {
          e.preventDefault();
          submitAnswer();
        }
      }

      // Main menu: number keys 1-6 to select level
      if (menuScreen.style.display === 'block') {
        if (e.key >= '1' && e.key <= '6') {
          e.preventDefault();
          const levelIndex = Number.parseInt(e.key) - 1;
          startLevel(levelIndex);
        }
      }
    }

    // Start level
    function startLevel(levelIndex) {
      gameState.currentLevel = levelIndex;
      gameState.currentQuestion = 0;
      gameState.startTime = Date.now();
      gameState.lastDividend = null;
      gameState.lastDivisor = null;

      menuScreen.style.display = 'none';
      gameScreen.style.display = 'block';
      gameContent.style.display = 'block';
      endScreen.classList.remove('show');

      startTimer();
      generateQuestion();
    }

    // Generate question
    function generateQuestion() {
      const level = LEVELS[gameState.currentLevel];
      let dividend, divisor, quotient;

      // Generate valid question, avoid consecutive duplicates
      do {
        // Divisor minimum is 2, avoid too easy
        divisor = generateNumber(level.divisorDigits, 2);
        quotient = Math.floor(Math.random() * 9) + 1; // 1-9
        const remainder = Math.floor(Math.random() * divisor);
        dividend = divisor * quotient + remainder;
      } while (
        !isValidDividend(dividend, level.dividendDigits) ||
        (dividend === gameState.lastDividend && divisor === gameState.lastDivisor)
      );

      // Record this question for next check
      gameState.lastDividend = dividend;
      gameState.lastDivisor = divisor;

      gameState.dividend = dividend;
      gameState.divisor = divisor;
      gameState.correctAnswer = quotient;
      gameState.currentQuestion++;

      displayQuestion();
    }

    // Generate number with specified digits
    function generateNumber(digits, minValue = 1) {
      let min = digits === 1 ? 1 : Math.pow(10, digits - 1);
      if (min < minValue) {
        min = minValue;
      }
      const max = Math.pow(10, digits) - 1;
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // Check if dividend meets digit requirements
    function isValidDividend(dividend, digits) {
      const min = digits === 1 ? 1 : Math.pow(10, digits - 1);
      const max = Math.pow(10, digits) - 1;
      return dividend >= min && dividend <= max;
    }

    // Display question
    // Display user's input in quotient cell
    function displayUserInput() {
      quotientCell.innerHTML = `<span class="quotient-display">${gameState.userInput}</span>`;
    }

    // Display empty placeholder in quotient cell
    function displayEmptyInput() {
      quotientCell.innerHTML = '<span class="quotient-placeholder">_</span>';
    }

    function displayQuestion() {
      questionCounter.textContent = t('questionCounter')(gameState.currentQuestion, TOTAL_QUESTIONS);

      // Set divisor and dividend
      divisorCell.textContent = gameState.divisor;
      dividendCell.textContent = gameState.dividend;

      // Make spacer same width as divisor
      divisorSpacer.textContent = gameState.divisor;
      divisorSpacer.style.visibility = 'hidden';

      // Reset user input and show placeholder
      gameState.userInput = null;
      displayEmptyInput();

      calculation.classList.remove('show');
      resultIcon.classList.remove('show', 'correct', 'incorrect');
      continueHint.classList.remove('show');
      continueHintMobile.classList.remove('show');
      penaltyHint.classList.remove('show');
      calcRemainder.classList.remove('correct', 'incorrect');

      gameState.waitingForEnter = false;

      // Ensure timer is running (for next question)
      if (!gameState.timerInterval) {
        startTimer();
      }
    }

    // Submit answer
    function submitAnswer() {
      const userAnswer = gameState.userInput;

      if (userAnswer === null || userAnswer < 0 || userAnswer > 9) {
        return;
      }

      // Calculate result
      const product = gameState.divisor * userAnswer;
      const remainder = gameState.dividend - product;

      // Show calculation process
      displayUserInput();
      calcProduct.textContent = `-${product}`;
      calcRemainder.textContent = remainder;
      calculation.classList.add('show');

      // Check correctness
      const isCorrect = remainder >= 0 && remainder < gameState.divisor;
      gameState.lastAnswerCorrect = isCorrect;
      gameState.waitingForEnter = true;

      if (isCorrect) {
        resultIcon.textContent = '‚úì';
        resultIcon.classList.add('show', 'correct');
        calcRemainder.classList.add('correct');
        playCorrectSound();
        stopTimer();  // Only pause on correct answer
      } else {
        resultIcon.textContent = '‚úó';
        resultIcon.classList.add('show', 'incorrect');
        calcRemainder.classList.add('incorrect');
        // Wrong answer: 10 second penalty, timer keeps running
        gameState.startTime -= 10000;
        updateTimer();
        penaltyHint.classList.add('show');
        playWrongSound();
      }

      continueHint.classList.add('show');
      continueHintMobile.classList.add('show');
    }

    // Reset question (when wrong)
    function resetQuestion() {
      // Reset user input and show placeholder
      gameState.userInput = null;
      displayEmptyInput();

      calculation.classList.remove('show');
      resultIcon.classList.remove('show', 'correct', 'incorrect');
      continueHint.classList.remove('show');
      continueHintMobile.classList.remove('show');
      penaltyHint.classList.remove('show');
      calcRemainder.classList.remove('correct', 'incorrect');

      gameState.waitingForEnter = false;

      // Resume timer
      startTimer();
    }

    // Next question
    function nextQuestion() {
      if (gameState.currentQuestion >= TOTAL_QUESTIONS) {
        endLevel();
      } else {
        generateQuestion();
      }
    }

    // End level
    function endLevel() {
      stopTimer();
      gameState.waitingForEnter = false; // Reset state
      const elapsed = (Date.now() - gameState.startTime) / 1000;

      gameContent.style.display = 'none';
      endScreen.classList.add('show');
      endTime.textContent = formatTime(elapsed);

      // Update best record
      const isNewRecord = saveBestTime(gameState.currentLevel, elapsed);
      newRecord.style.display = isNewRecord ? 'block' : 'none';
    }

    // Return to menu
    function goToMenu() {
      stopTimer();
      menuScreen.style.display = 'block';
      gameScreen.style.display = 'none';
      renderLevelButtons();
    }

    // Timer functions
    function startTimer() {
      // Clear any existing interval first to prevent duplicates
      if (gameState.timerInterval) {
        clearInterval(gameState.timerInterval);
      }
      gameState.timerInterval = setInterval(updateTimer, 100);
      timerDisplay.classList.remove('paused');
    }

    function stopTimer() {
      if (gameState.timerInterval) {
        clearInterval(gameState.timerInterval);
        gameState.timerInterval = null;
      }
      timerDisplay.classList.add('paused');
    }

    function updateTimer() {
      const elapsed = (Date.now() - gameState.startTime) / 1000;
      timerDisplay.textContent = formatTime(elapsed);
    }

    // Format time
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = (seconds % 60).toFixed(1);
      return `${mins}:${secs.padStart(4, '0')}`;
    }

    // Initialize game
    init();
  </script>
</body>
</html>
